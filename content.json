[{"title":"细说结构体","date":"2019-12-24T22:20:21.000Z","path":"2019/12/25/细说结构体/","text":"结构体的基本操作 这个数据类型可以用来表复杂的数据类型，由于C语言中的数组只能存放相同的数组类型，此时可以通过结构体来表示复杂的数据类型。在学习结构体过程中可以把 结构体看作类（相当于模型），结构体变量看作实例。结构体里面有很多成员属性。 结构体的定义 先声明结构体再定义结构体变量 1234567struct book&#123; //把book看成类名 char name[40]; //书名称 char author[40];//作者名 float price; //单价&#125;;//上面定义结构体后再定义结构体变量名struct book php; //php 称之为结构体变量名 在声明结构体同时定义结构体变量 12345struct book&#123; char name[40]; char author[40]; float price; &#125;php,c++,c,java;//在定义结构体后可以直接定义结构体变量名（可以定义多个变量名） 省略结构体名同时定义结构体变量 12345struct&#123; //结构体名省略 char name[40]; char author[40]; float price; &#125;php,c++,c,java;//此时结构体变量名必须定义时紧跟后了 使用typedef关键字定义的结构体（详细看typedef的使用） 结构体的赋值 12345678910111213141516171819202122//方式一struct book&#123; char name[40]; char author[40];&#125;;struct book php=&#123;\"php入门到精通\",\"chenweiqin\"&#125;;//方式二struct book&#123; char name[40]; char author[40];&#125;php=&#123;\"php入门到精通\",\"chenweiqin\"&#125;;//方式三struct book&#123; char name[40]; char author[40];&#125;php;//也可以通过.或者-&gt;(如果是指针变量名)strcpy(php.name,\"php入门到精通\");struct book * p_php = &amp;php;//赋值给指针strcpy(P_php-&gt;name,\"php入门到精通\");stucpy((&amp;php)-&gt;name,\"php入门到精通\");//以上操作效果是一样的 结构体的读取 1234567891011121314struct book&#123; char name[40]; float price;&#125;;struct book php;//赋值strcpy(php.name,\"php入门到精通\");//或者通过指针方式strcpy((&amp;php)-&gt;name,\"php入门到精通\");php.price = 99.9;//读取时可以通过.或-&gt;printf(\"name=%s,price=%f\",php.name,php.price);printf(\"name=%s,price=%f\",(&amp;php)-&gt;name,(&amp;php)-&gt;price); 结构体成员定义的顺序影响占用内存空间的大小 结构体的成员定义的顺序会影响会影响结构体变量在战胜空间的大小，因为结构定义过程中是按照成员中最大的那种数据类型，考虑的是先把最大那个数据类型装下再说，然后根据内存对齐．但这种有一个缺点，省了内存空间但不利于代码的阅读． 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;struct stu &#123; char name[20];//20 unsigned int age;//4 char tel[15];//15 float scores[3];//12 char sex;//1 &#125;s1;//把上面最后成员属性调换位置struct stu &#123; char name[20];//20 unsigned int age;//4 char tel[15];//15 char sex;//1 float scores[3];//12&#125;s2;int main(void) &#123; printf(\"s1=%d,s2=%d\",sizeof(s1),sizeof(s2));//56,52&#125;//最大的数据类型为int或float 即为4B,所有分配单位为4B/* char name[20];//20 刚好分 5*4 unsigned int age;//4 刚好分1*4 char tel[15];//15 实占了16 这里只能分配4*4 剩下1B没有被下面成员属性利用上 float scores[3];//12 刚好分 3*4 char sex;//1 实占4 1*4 这里分配是4B而不是1B,因为要考滤到内存对齐． char name[20];//20 刚好分 5*4 unsigned int age;//4 刚好分1*4 char tel[15];//15 实占了16 这里只能分配4*4 剩下1B char sex;//1 实占1 能否利用上一个成员剩下空间，就看当前成员数据类型值是否小于或等于剩下空间值 float scores[3];//12 刚好分 3*4 */ 通过指针的方式来操作结构体指向普通结构体变量的指针 12345678910111213141516&gt;struct person&#123; char name[20]; int age;&gt;&#125;;&gt;int main()&#123; struct person stu = &#123;\"lily\",18&#125;; //通过指针变量方式来操作 struct person * pStu = &amp;stu; printf(\"name=%s,age=%d\",Pstu-&gt;name,Pstu-&gt;age); printf(\"name=%s,age=%d\",(&amp;stu)-&gt;name,(&amp;stu)-&gt;age); printf(\"name=%s,age=%d\",(*Pstu).name,(*Pstu).age); printf(\"name=%s,age=%d\",stu.name,stu.age); //详情看关于指针 return 0;&gt;&#125; 堆区结构体变量 把结构变量保存在堆区中 123456789101112131415&gt;struct person&#123; char name[20]; int age;&gt;&#125;;&gt;int main()&#123; //定义结构类的指针 struct person * p1 = NULL; p1 = (struct person *) malloc(sizeof(struct person)); //后期赋值只能通过strcpy strcpy(p1-&gt;name,\"lily\"); p1-&gt;age = 18; free(p1);//用完了记得释放 p1 = NULL; return 0;&gt;&#125; 结构体套一级指针 123456789101112131415161718192021&gt;struct person&#123;char * name;int age;&gt;&#125;;&gt;int main()&#123; struct person * p1 = NULL; p1 = (struct person *) malloc(sizeof(struct person)); p1-&gt;name = (char *) malloc(strlen(\"lily\")+1);//如果使用sizeof则不用加1 strcpy(p1-&gt;name,\"lily\"); p1-&gt;age = 18; //释放内存 if(NULL != p1-&gt;name)&#123; free(p1-&gt;name); p1-&gt;name = NULL; &#125; if(NULL != p1)&#123; free(p1); p1 = NULL; &#125; return 0;&gt;&#125; 结构体数组 12345678910111213141516171819struct person&#123; int id; char name[20]; float score;&#125;//结构体数组int main()&#123; struct person stu[2] = &#123; &#123;1,\"lily\",88.5&#125;, &#123;2,\"jack\",89.5&#125; &#125;; //求总分 int i = 0; flaot s = 0; for(i =0; i&lt;2; i++)&#123; s += stu[i].score; &#125;&#125; 结构体套结构体 1234567891011121314151617181920struct person&#123; char name[20]; char sex;&#125;;struct stu&#123; int id; struct person stdInfo;&#125;;int main()&#123; struct stu allStu[2]= &#123;1,\"lisi\",\"f\",2,\"lily\",\"M\"&#125;;//它会自动划分好，下面定义更清晰 struct stu allStu[2]= &#123; &#123;1,\"lisi\",\"f\"&#125;, &#123;2,\"lily\",\"M\"&#125; &#125;;//这是结构体数组 int i =0; for(i = 0; i &lt; 2; i++)&#123; printf(\"id=%d,stdInfo.name=%s,stdInfo.sex=%c\",allStu[i].id,allStu[i].stdInfo.name,allStu[i].stdInfo.sex);//在结构体套结构体时在读取要小心 &#125;&#125; 结构体作为形参按值传递 12345678910111213141516struct stu&#123; char name[20]; int age;&#125;;void setInfo(struct stu tmp)&#123; strcpy(tmp.name,\"lily\"); tmp.age = 18; printf(\"name=%s,age=%d\",tmp.name,tmp.age);&#125;int main()&#123; struct stu s = &#123;0&#125;; setInof(s); //按值传递 printf(\"name=%s,age=%d\",s.name,s.age); //结果没有被改变 return 0;&#125; 按引用传递 123456789101112131415&gt;struct stu&#123; char name[20]; int age;&gt;&#125;;&gt;void setInfo(struct stu * tmp)&#123; strcpy(tmp-&gt;name,\"lily\"); tmp-&gt;age = 18; printf(\"name=%s,age=%d\",tmp.name,tmp.age);&gt;&#125;&gt;int main()&#123; struct stu s = &#123;0&#125;; setInof(&amp;s); //按值传递 printf(\"name=%s,age=%d\",s.name,s.age); //结果被改变 return 0;&gt;&#125; 结构体数组为参数 12345678910111213141516171819struct stu&#123; char name[20]; int age;&#125;;void setInfo(struct stu * tmp,int n)&#123; int i =0; sprintf(tmp-&gt;name,\"stuname%d\",i); tmp-&gt;age = 80+i; tmp++; //相当于移动一个结构中的一个元素&#125;int main()&#123; struct stu s[2] = &#123;0&#125; int i =0; int n = sizeof(s)/sizeof(sizeof(s[0])); setInfo(s,n);//数组默认传是引用 for(i=0;i&lt;n;i++)&#123; printf(\"%s, %d\\n\", s[i].name, s[i].age); &#125;&#125; const修饰结构体形参 const 关键字修饰起到防止对源数据的更改 1234567891011121314151617181920&gt;//结构体类型的定义&gt;struct stu&#123;char name[20];int age;&gt;&#125;;&gt;//注意const所在的位置（更详细搜：const全局变量与const局部变量区别）&gt;void fun1(struct stu * const p)&#123;//p = NULL; //errp-&gt;age = 10; //ok&gt;&#125; &gt;//void fun2(struct stu const* p)&gt;void fun2(const struct stu * p)&#123;p = NULL; //ok//p-&gt;age = 10; //err&gt;&#125;&gt;void fun3(const struct stu * const p)&#123;//p = NULL; //err//p-&gt;age = 10; //err&gt;&#125;","link":"","categories":[{"name":"C","slug":"C","permalink":"http://www.chenweiqin.com/categories/C/"}],"tags":[{"name":"C基础","slug":"C基础","permalink":"http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"}]},{"title":"sizeof的用法及与strlen比较","date":"2019-12-12T08:32:03.000Z","path":"2019/12/12/sizeof的用法及与strlen比较/","text":"sizeof与strlen比较 相同点： 返回值都以字节为单位,无符号整型值,为什么要强调这一点，当无符号整型与有符号整型进行运行时，一般会返回无符号值，在下面会举例说明。 不同点： sizeof是运算符，会计算出变量类型所占的大小或变量实际占用大小，而strlen是函数返回字符串有效的长度，而不会加上\\0，即字符串结束符。 12345int main()&#123; char str[] = \"hello\"; printf(\"%d\\n\",sizeof(str));//6 printf(\"%d\\n\",strlen(str));//5 因为不没有把\\0计算进来&#125;","link":"","categories":[{"name":"C","slug":"C","permalink":"http://www.chenweiqin.com/categories/C/"}],"tags":[{"name":"C基础","slug":"C基础","permalink":"http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"}]},{"title":"typedef用法","date":"2019-12-11T13:51:03.000Z","path":"2019/12/11/typedef用法/","text":"typedef与define的区别 #define发生在预处理，typedef发生在编译阶段 与#define不同，typedef限于数据类型，而不是能表达式或具体的值 二、具体使用对比 宏替换，只能使用#define,如果#define PI 3.14 简单起别名 #define uint32 unsigned int或typedef unsigned int uint32;其实这两个是一样的。 ＃define 只有前者生效 #define PCHAR char *; PCHAR p1,p2;只有p1被声明为指针，但如果换成typedef 效果就不一样了。typedef char * PCHAR; PCHAR P1,P2; 此时p1,p2都被声明为指针 ＃define 无法用于简化结构体的定义。#definde struct book{}; 编译是无法通过的 typedef的用法解决兼容不同平台引起的差异问题 123456typedef long double REAL;//但有些版本不支持long double 则可以改为typedef double REAL;//还不支持的话再改typedef float REAL;//这样//在文件中定义变量时使用更为兼容的写法REAL a;//等价于 float a; 起到等价写法 用于等价标记 123456char *p1,p2;//前是为char *类型，后者为char//如果想定义成两种都是char *类型，则必须要这样定义char *p1,*p2;//能否找到一种与上面等价的写法typedef char * p_str;p_str p1,p2;//与char *p1,*p2;定义的方式效果是一样的 用于结构体时简化了写法 12345678910111213141516171819202122232425//平时在定义结构体struct person&#123; int age; char name[40];&#125;;//接着使用结构体int test()&#123; struct person lisi = &#123;20,\"lisi\"&#125;; struct person zhangsan = &#123;21,\"zhangsan\"&#125;;&#125;//当使用typedef后typedef struct person&#123; int age; char name[40];&#125;TYPE_P;//可以把上面的person也简写了//使用结构体int test2()&#123; TYPE_P lisi=&#123;20,\"lisi\"&#125;; TYPE_P zhangsan=&#123;20,\"zhangsan\"&#125;;&#125; 小心在引用自身时会报错，因为typedef发生在编译阶段 1234567891011121314151617181920typedef struct tagNode&#123; char *pItem; pNode pNext; //因为它还没有存在PNode&#125; *pNode;//正确使用方式typedef struct tagNode *pNode;struct tagNode&#123; char *pItem; pNode pNext;&#125;//或者以下这种方式struct tagNode&#123; char *pItem; struct tagNode *pNext;&#125;;typedef struct tagNode *pNode; 同样可以简化指定及数组定义 1234567typedef int INT_ARR_10[10];//上面定义后，就可以使用它INT_ARR_10 arr;//简化指针的定义typedef char * PCHAR;PCHAR name;// 等价于char * name; 更为高级用法简化函数的定义 1234567891011121314typedef int (*Function)(const char *, const char *);//使用时Function test;//等价于 int test(const char *, const char *);int *(*a[5])(int,char*);// PFun是我们创建的一个类型别名typedef int *(*PFun)(int,char*);// 使用定义的新类型来声明对象，等价于int*(*a[5])(int,char*);PFun a[5];typedef void (*HANDLER)(int);HANDLER Signal(int,HANDLER);//等价于void (*Signal(int,void(*)(int)))(int); typedef注意事项 1234567typedef char* PCHAR;int mystrcmp(const PCHAR,const PCHAR);//它是等价于int mystrcmp(char* const,char* const);//而非是等价于int mystrcmp(const char* ,const char* );//要想得到上面的效果则更改为typedef const char * PCHAR;int mystrcmp(PCHAR,PCHAR); 还需要特别注意的是，虽然 typedef 并不真正影响对象的存储特性，但在语法上它还是一个存储类的关键字，就像 auto、extern、static 和 register 等关键字一样。因此，像下面这种声明方式是不可行的： 1typedef static int INT_STATIC; 不可行的原因是不能声明多个存储类关键字，由于 typedef 已经占据了存储类关键字的位置，因此，在 typedef 声明中就不能够再使用 static 或任何其他存储类关键字了。当然，编译器也会报错，如在 VC++2010 中的报错信息为“无法指定多个存储类”。","link":"","categories":[{"name":"C","slug":"C","permalink":"http://www.chenweiqin.com/categories/C/"}],"tags":[{"name":"C基础","slug":"C基础","permalink":"http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"}]},{"title":"内存管理","date":"2019-12-03T02:57:19.000Z","path":"2019/12/03/内存管理/","text":"作用域变量作用域 一 、C语言的变量作用域分为： 代码块作用域（代码块作用域就是在{}之间的代码） 函数作用域 文件作用域 二、如果按作用范围分则分为： 局部变量 局部变量分划分为静态与非静态局部变量 1.1 非静态局部变量（也称之为auto自动变量，auto可以省略不写） 在函数内定义，只在函数范围内有效 在复合语句中定义，只在复合语句中有效（如:if(){//在这里定义了变量只在这里生效}） 随着函数调用的结束或复合语句的结束局部变量的生命周期也结束 如果没有赋初始值，则系统随机分配值（即垃圾值） 1.2 静态局部变量（使用static进行修饰） static 局部变量的作用域也是在所定义的函数内生效 static 局部变量的生命周期和程序运行周期一样 static 局部变量只能被初始化一次，但可以多次赋值 static 局部变量没有赋以初值时，系统则会对int型赋上0，字符型变量赋空字符串 全局变量 全局变量同样可以划分为静态与非静态全局变量 2.1 非静态全局变量 在函数外定义，可被本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量，须用extern 声明 全局变量的生命周期和程序运行同期一样 不同文件的局部变量不同重名 2.2 静态全局变量 在函数外定义，作用范围被限制在所定义的文件中 不同的文件静态全局变量可以重名，便作用域不冲突 生命与程序运行周期一样，同时也只能被初始化一次 函数作用域 把C言语中函数可以划分为静态与非静态全局函数，因为在C语言中函数默认是全局的，使用了static修饰后称之为静态全局函数。 静态全局函数 此函数只能在当前文件中使用，不能别的文件中使用 不同的文件名中如果是静态函数文件名是可以相同的 小结一下： 允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰。 同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。 所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。 内存分区内存分区的意义 将程序中不同的数据存放在不同的区域中（分区中），赋予它们不同的生命周期，给编程带来更大的灵活性。搞清楚每个区存放的数据时有什么特点，各种变量类型分别存放在那些分区中。不然在编写函数过程中往往接收不到函数的返回值，因为你接收的数据是存放在栈区，而函数调用结束后，由系统自动回收栈中的资源，有时在定义一个比较的数组时程序会报错，这是因为栈区的大小是固定的不能存比较大的数据。 阅读一个程序在内存中分区模型为会两种，一种是程序未执行时，另一种是当程序执行起来时，为什么可以这样划分？因为一个程序编译完成如果将这个程序运行起来在内存占的数据大小的是固定的（因为这些数据能预测出来），如（这个程序所有的指令长，静态数据/全局初始化数据/未初始数据），特点说明真正占用存内空间还是等到程序起来。还是数据只有程序真正运行起来才能知道占用内存的数据（如开辟了多个栈空间，申请了多少堆内存） 程序未执行时：一个c程序经过 预处理 编译 汇编 链接 4步后生成可执行文件。可能通过size 命令看到相关的信息。 通过上图得知，在没有运行程序前，也就是程序没有加载到内存前，可执行程序程序内部分好3区信息，分别为代码区（text）、初始化数据区（data）和未初始化数据区（bss）3个分区（有些人直接把data和bss合起来叫做静态区或全局区） 程序加载到内存时：代码区和全局区（data与bss）的大小就是固定不变的，当程序运行起来后，多了2个分区，分别是栈区与堆区 划分内存四区模型 在理解C/C++内在分区时，常会碰到如下术语：数据区，栈区，堆区，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等，把搞得云里雾里，在我眼里再把统一分类，程序是由数据与指令组成的则把它划分为2个区：数据区与代码区 数据区：堆区，栈区，全局区/静态区 全局区/静态区：常量区，全局区/静态区[ =初始化数据区（data）和未初始化数据区（bss）]，以后别人说什么全局区/静态区就认为是：常量区+初始化数据区（data）+未初始化数据区（bss） 常量区：字符串常量区，const修饰全局变量 代码区：存放程序编译后的二进制代码（也是机器指令） 各个分区特性 代码区 共享，只读不可修改。如运行了两个QQ.exe那么它的代码区是共享的，如果代码区中的内存不受保护那么程序就没有安全性可言了。 全局区 包括数据区 静态区 常量区。 生存周期为整个程序运行过程。 常量区的数据一量初始化，之后就是能修改了，只能读取。（如：”hello world” 符串常量，const修饰的全局变量 都是放在常量区的） 栈区 先进后出，由系统自动分配与释放。如函数的形参、返回值、局部变量，在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间即函数调用结束。栈区大小固定的，不能存放比较大的数据。 堆区 堆区是一个大容器，它的容量远远大于栈区，但没有栈那样先进后出的顺序。用于动态内存分配，堆区在内存中位于BSS区和栈区之间，一定要在程序手动申请手动释放，如果没有手动释放则会在程序结束时由操作系统回收，好是养成好的习惯用完了就把它释放掉 理解各个分区的案例 全局区 １、把它们都定义在函数外面（即作用域全局有效）extern int flag=1 与 static int flag=1 有什么区别？ 答：它们都是全局区，生存周期为程序运行结束，前者称之为外部链接符号，后者称之为内部链接号，说白了后者是在当前文件中全局有效，但不能跨文件使用它，前者无论是当前文件还是其它文件都可以使用它，使用时要加extern int flag , 告诉一下给编译器即可。 ２、定义在函数外的static int a=1 与定义在函数内的static int a=1有什么区别？ 答：相同点它们都是在静态区，生存周期为整个程序运行结束，不同点是前者的作用域为当前文件内全局有效，后者是局部变量，只能当前函数中使用。 栈区 1234567891011int * myFunc()&#123; //不要返回局部变量的地址,因为它是栈区中的 int a =10; return &amp;a;&#125;void test()&#123; int *P = myFunc(); printf(\"*p=%d\",*p);//得到的值是不确定的，可能是正确值，也有可以是垃圾值&#125; 再看一下面的案例 1234567891011char * getString()&#123; char str[] = \"hello world\"; return str;&#125;void test()&#123; char *s =NULL; s = getString(); printf(\"s=%s\\n\",s);&#125; 堆区 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int *getSpace()&#123; int *p = malloc(sizeof(int)*5); if(NULL == p)&#123; return NULL; &#125; //printf(\"%d\\n\",*&amp;p); //printf(\"%d\\n\",p); int j =0; for(int i=0;i&lt;5;i++) &#123; p[i] = 100+i; &#125; return p;//返回p里面的值&#125;void test()&#123; int * ret = getSpace(); for(int i=0;i&lt;5;++i)&#123; printf(\"%d\\n\",ret[i]); &#125; free(ret); ret = NULL;&#125;int main(void) &#123; test();&#125;//能正确输出结果 以上结果是正确输出hello world 那么如果正确输出正确有的结果，如下转化以下操作 常量区 const全局变量与const局部变量区别？ 1234567891011121314151617181920212223//1.const全局变量与const局部变量区别？除作用域不一样，它们所在内存中存放区也不一样（前都在数据区（也称之为全局区），后者是存放在栈区的）//const全局变量在常量区，不能修改(直接或者间接都不能修改)const int g_c = 100;//全局变量，存放在数据区void test03()&#123; //直接修改不行 //g_c=200 错误 //间接修改也不行 int *p = (int *)&amp;g_c;//&amp;g_c 是const int * 类型的，所有要强转换一下 *p = 200; //全局const放在常量区，一旦初始化，不能修改&#125; //2.const局部变量void test04()&#123; //栈上,它分配中在栈上，可以间接的修改它的值 const int a = 100;//局部 存放在栈区 //a=200;不能够直接改变它的值 int *p = &amp;a; *p = 200; printf(\"a=%d\\n\", a);&#125; “hello world” 可以看成变量名;&amp;”hello world” 就可以打印出地址来 ,关于两个相同的字符串常量是否相同得出结论如下： tc2.0,同文件字符串常量地址不同。 vs2013,字符串常量地址同文件和不同文件都相同。 QT,同文件相同，不同文件不同。 动态操作内存内存操作常见函数 malloc() vaoid *malloc(int size) 功能：在内存的动态存储区（堆区）中申请一块长度为size字节的连续区域 参数：size 需要申请内存大小(单位：字节) 返回值：注意如果当前内存不够的情况下有可能申请不成功，如果成功返回首地址（指针），失败返回NULL 注意事项：使用后必须进行内存回收，即malloc与free函数成对使用，对申请到内存空间进行及时释放，防止内存溢出 1234567891011121314151617181920int * array;array = (int *) malloca(sizeof(int)*10);//申请到一块连续内存大小为:4*10=40字节if(array == NULL)&#123; //必须判断是否申请成功 printf(\"申请空间失败\\n\"); return -1;&#125;//对申请的内存空间进行初始化操作memset(array,0,sizeof(int)*10);//把申请内存空间上的每个字节都重置为0//对申请到空间进行赋值操作int i;for(i=0; i&lt; 10;i++)&#123; array[i] = i;//在申请成功赋值给了int*类型指针，所有在这里可以用下标或者指针方式进行赋值操作&#125;//读取结果for(i=0;i&lt; 10; i++)&#123; printf(\"%d\\n\",array[i]);&#125;//使用后记得释放,防止内存溢出free(array); free() void free(void * p) 功能：释放p所指向的那一块内存空间，为释放区域的首地址，对同一个内存空间多次释放会报错 参数：p为释放空间的首地址 返回值：无 memset() void *memset(void *s ,int value, int sizse) 功能：将以s为首地址重置为值为value,重置长度为size,特别说明size单位为字节 参数： s : 操作的首地址 value: 把指定长度上的每个字节都重置为value，（一个字节占8位，所有value范围为0~255 一般使用值0） size:要重置的长度（字节数） 12345int a[10];memset(a,0,sizeof(a));//把里面每个字节都重置为0char * str = (char *) malloc(sizeof(char)*10);memset(str,96,10);//即重置为了\"AAAAAAAAAA\"free(str); memcpy() void * memcpy(void * dest,const void * src, int size); 功能：拷贝src所指向内存内容前n个字节到dest所指的内存地址中 参数： dest: 目的内存首地址 src: 源内存的首地址，注意:dest与src所指的内存空间不能重叠 size : 拷贝的字节数 返回值：dest 的首地址 123int a[5] = &#123;1,2,3,4,5&#125;;int b[5];memcpy(b,a,sizeof(a));//把a数组中内容复制一份到b中 memmove() 功能与memcpy一样，区别于dest和src的所指向的内存空间出现重叠时，memmove仍然能执行，它执行效率比memcpy低 memcmp() int memcmp(const void * s1,const void * s2, int size); 功能：比较s1和s2所指向内存区域的前size个字节 参数： s1:内存首地址１ s2:内存首地址２ size: 要比较的前多少个字节 返回值： 如果比较结果值相等:返回0, 大于:返回的值为&gt;0, 小于：返回的值为&lt;0 calloc () 功能：分配空间并清空，等同于malloc + memset realloc() 功能：重新分配内存空间，用于扩展和缩小空间 参数说明： 第一参数 第二个参数 行为 空 无 同malloc 非空 ０ 原内存块被释放 非空 比原内存块小 利用当前位置分配更小的内存块 非空 比原内存块大 利用当前位置分配更大的内存块","link":"","categories":[{"name":"C","slug":"C","permalink":"http://www.chenweiqin.com/categories/C/"}],"tags":[{"name":"C基础","slug":"C基础","permalink":"http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"}]},{"title":"指针","date":"2019-11-27T22:34:21.000Z","path":"2019/11/28/指针/","text":"什么是指针2018年10月25日 - 此系列文章我们开始聊一些软件开发人员如何开始动手写一些自己项目(Side Project)的思路与方法,以及过程中可能需要准备的知识,并分享一些相关的资源给.. 指针与数组关系通过指针写读取数组2018年10月25日 - 此系列文章我们开始聊一些软件开发人员如何开始动手写一些自己项目(Side Project)的思路与方法,以及过程中可能需要准备的知识,并分享一些相关的资源给… 通过指针操作二维数组2018年10月25日 - 此系列文章我们开始聊一些软件开发人员如何开始动手写一些自己项目(Side Project)的思路与方法,以及过程中可能需要准备的知识,并分享一些相关的资源给… 指针与函数指针作为函数参数时指针作为函数返回值指针的运算","link":"","categories":[{"name":"C","slug":"C","permalink":"http://www.chenweiqin.com/categories/C/"}],"tags":[{"name":"C基础","slug":"C基础","permalink":"http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"},{"name":"指针","slug":"指针","permalink":"http://www.chenweiqin.com/tags/%E6%8C%87%E9%92%88/"}]}]