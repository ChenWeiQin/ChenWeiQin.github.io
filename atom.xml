<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Weiqin&#39;Blog</title>
  
  <subtitle>I can accept failure, but I cannot accept giving up.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenweiqin.com/"/>
  <updated>2019-12-26T10:04:29.554Z</updated>
  <id>http://www.chenweiqin.com/</id>
  
  <author>
    <name>陈维勤</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>细说结构体</title>
    <link href="http://www.chenweiqin.com/2019/12/25/%E7%BB%86%E8%AF%B4%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://www.chenweiqin.com/2019/12/25/细说结构体/</id>
    <published>2019-12-24T22:20:21.000Z</published>
    <updated>2019-12-26T10:04:29.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构体的基本操作"><a href="#结构体的基本操作" class="headerlink" title="结构体的基本操作"></a>结构体的基本操作</h2><blockquote><p>这个数据类型可以用来表复杂的数据类型，由于C语言中的数组只能存放相同的数组类型，此时可以通过结构体来表示复杂的数据类型。在学习结构体过程中可以把　结构体看作类（相当于模型），结构体变量看作实例。结构体里面有很多成员属性。</p></blockquote><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><blockquote><ol><li><p>先声明结构体再定义结构体变量</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span>　<span class="comment">//把book看成类名</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>]; <span class="comment">//书名称</span></span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">40</span>];<span class="comment">//作者名</span></span><br><span class="line">    <span class="keyword">float</span> price;　<span class="comment">//单价</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//上面定义结构体后再定义结构体变量名</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">php</span>;</span> <span class="comment">//php 称之为结构体变量名</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在声明结构体同时定义结构体变量</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span>　</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>]; </span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">float</span> price;　</span><br><span class="line">&#125;php,c++,c,java;<span class="comment">//在定义结构体后可以直接定义结构体变量名（可以定义多个变量名）</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>省略结构体名同时定义结构体变量</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span>　<span class="comment">//结构体名省略</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>]; </span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">float</span> price;　</span><br><span class="line">&#125;php,c++,c,java;<span class="comment">//此时结构体变量名必须定义时紧跟后了</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>使用typedef关键字定义的结构体（详细看typedef的使用）</p></li></ol></blockquote><h3 id="结构体的赋值"><a href="#结构体的赋值" class="headerlink" title="结构体的赋值"></a>结构体的赋值</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">php</span>=&#123;</span><span class="string">"php入门到精通"</span>,<span class="string">"chenweiqin"</span>&#125;;</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">&#125;php=&#123;<span class="string">"php入门到精通"</span>,<span class="string">"chenweiqin"</span>&#125;;</span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">&#125;php;</span><br><span class="line"><span class="comment">//也可以通过.或者-&gt;(如果是指针变量名)</span></span><br><span class="line"><span class="built_in">strcpy</span>(php.name,<span class="string">"php入门到精通"</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> * <span class="title">p_php</span> = &amp;<span class="title">php</span>;</span><span class="comment">//赋值给指针</span></span><br><span class="line"><span class="built_in">strcpy</span>(P_php-&gt;name,<span class="string">"php入门到精通"</span>);</span><br><span class="line">stucpy((&amp;php)-&gt;name,<span class="string">"php入门到精通"</span>);<span class="comment">//以上操作效果是一样的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="结构体的读取"><a href="#结构体的读取" class="headerlink" title="结构体的读取"></a>结构体的读取</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">php</span>;</span></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(php.name,<span class="string">"php入门到精通"</span>);</span><br><span class="line"><span class="comment">//或者通过指针方式</span></span><br><span class="line"><span class="built_in">strcpy</span>((&amp;php)-&gt;name,<span class="string">"php入门到精通"</span>);</span><br><span class="line">php.price = <span class="number">99.9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取时可以通过.或-&gt;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"name=%s,price=%f"</span>,php.name,php.price);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"name=%s,price=%f"</span>,(&amp;php)-&gt;name,(&amp;php)-&gt;price);</span><br></pre></td></tr></table></figure></blockquote><h3 id="结构体成员定义的顺序影响占用内存空间的大小"><a href="#结构体成员定义的顺序影响占用内存空间的大小" class="headerlink" title="结构体成员定义的顺序影响占用内存空间的大小"></a>结构体成员定义的顺序影响占用内存空间的大小</h3><blockquote><p>结构体的成员定义的顺序会影响会影响结构体变量在战胜空间的大小，因为结构定义过程中是按照成员中最大的那种数据类型，考虑的是先把最大那个数据类型装下再说，然后根据内存对齐．但这种有一个缺点，省了内存空间但不利于代码的阅读．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];<span class="comment">//20</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;<span class="comment">//4</span></span><br><span class="line">    <span class="keyword">char</span> tel[<span class="number">15</span>];<span class="comment">//15</span></span><br><span class="line">    <span class="keyword">float</span> scores[<span class="number">3</span>];<span class="comment">//12</span></span><br><span class="line">    <span class="keyword">char</span> sex;<span class="comment">//1  </span></span><br><span class="line">&#125;s1;</span><br><span class="line"><span class="comment">//把上面最后成员属性调换位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];<span class="comment">//20</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;<span class="comment">//4</span></span><br><span class="line">    <span class="keyword">char</span> tel[<span class="number">15</span>];<span class="comment">//15</span></span><br><span class="line">    <span class="keyword">char</span> sex;<span class="comment">//1  </span></span><br><span class="line">     <span class="keyword">float</span> scores[<span class="number">3</span>];<span class="comment">//12</span></span><br><span class="line">&#125;s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"s1=%d,s2=%d"</span>,<span class="keyword">sizeof</span>(s1),<span class="keyword">sizeof</span>(s2));<span class="comment">//56,52</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最大的数据类型为int或float 即为4B,所有分配单位为4B</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> char name[20];//20 刚好分 5*4</span></span><br><span class="line"><span class="comment"> unsigned int age;//4 刚好分1*4</span></span><br><span class="line"><span class="comment"> char tel[15];//15 实占了16  这里只能分配4*4 剩下1B没有被下面成员属性利用上</span></span><br><span class="line"><span class="comment"> float scores[3];//12　刚好分　3*4</span></span><br><span class="line"><span class="comment"> char sex;//1 实占4 1*4 这里分配是4B而不是1B,因为要考滤到内存对齐．</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  char name[20];//20 刚好分 5*4</span></span><br><span class="line"><span class="comment"> unsigned int age;//4 刚好分1*4</span></span><br><span class="line"><span class="comment"> char tel[15];//15 实占了16  这里只能分配4*4 剩下1B</span></span><br><span class="line"><span class="comment"> char sex;//1 实占1 能否利用上一个成员剩下空间，就看当前成员数据类型值是否小于或等于剩下空间值</span></span><br><span class="line"><span class="comment"> float scores[3];//12　刚好分　3*4</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="通过指针的方式来操作结构体"><a href="#通过指针的方式来操作结构体" class="headerlink" title="通过指针的方式来操作结构体"></a>通过指针的方式来操作结构体</h2><h3 id="指向普通结构体变量的指针"><a href="#指向普通结构体变量的指针" class="headerlink" title="指向普通结构体变量的指针"></a>指向普通结构体变量的指针</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">stu</span> = &#123;</span><span class="string">"lily"</span>,<span class="number">18</span>&#125;;</span><br><span class="line">   <span class="comment">//通过指针变量方式来操作</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">pStu</span> = &amp;<span class="title">stu</span>;</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"name=%s,age=%d"</span>,Pstu-&gt;name,Pstu-&gt;age);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"name=%s,age=%d"</span>,(&amp;stu)-&gt;name,(&amp;stu)-&gt;age);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"name=%s,age=%d"</span>,(*Pstu).name,(*Pstu).age);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"name=%s,age=%d"</span>,stu.name,stu.age);</span><br><span class="line">   <span class="comment">//详情看关于指针</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="堆区结构体变量"><a href="#堆区结构体变量" class="headerlink" title="堆区结构体变量"></a>堆区结构体变量</h3><blockquote><p>把结构变量保存在堆区中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//定义结构类的指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p1</span> = <span class="title">NULL</span>;</span></span><br><span class="line">   p1 = (struct person *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct person));</span><br><span class="line">   <span class="comment">//后期赋值只能通过strcpy</span></span><br><span class="line">   <span class="built_in">strcpy</span>(p1-&gt;name,<span class="string">"lily"</span>);</span><br><span class="line">   p1-&gt;age = <span class="number">18</span>;</span><br><span class="line">   <span class="built_in">free</span>(p1);<span class="comment">//用完了记得释放</span></span><br><span class="line">   p1 = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="结构体套一级指针"><a href="#结构体套一级指针" class="headerlink" title="结构体套一级指针"></a>结构体套一级指针</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> * name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p1</span> = <span class="title">NULL</span>;</span></span><br><span class="line">   p1 = (struct person *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct person));</span><br><span class="line">   p1-&gt;name = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">"lily"</span>)+<span class="number">1</span>);<span class="comment">//如果使用sizeof则不用加1</span></span><br><span class="line">   <span class="built_in">strcpy</span>(p1-&gt;name,<span class="string">"lily"</span>);</span><br><span class="line">   p1-&gt;age = <span class="number">18</span>;</span><br><span class="line">   <span class="comment">//释放内存</span></span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">NULL</span> != p1-&gt;name)&#123;</span><br><span class="line">       <span class="built_in">free</span>(p1-&gt;name);</span><br><span class="line">       p1-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">NULL</span> != p1)&#123;</span><br><span class="line">       <span class="built_in">free</span>(p1);</span><br><span class="line">       p1 = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">stu</span>[2] = &#123;</span></span><br><span class="line">        &#123;<span class="number">1</span>,<span class="string">"lily"</span>,<span class="number">88.5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="string">"jack"</span>,<span class="number">89.5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//求总分</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    flaot s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">        s += stu[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="结构体套结构体"><a href="#结构体套结构体" class="headerlink" title="结构体套结构体"></a>结构体套结构体</h2><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">stdInfo</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">allStu</span>[2]= &#123;</span><span class="number">1</span>,<span class="string">"lisi"</span>,<span class="string">"f"</span>,<span class="number">2</span>,<span class="string">"lily"</span>,<span class="string">"M"</span>&#125;;<span class="comment">//它会自动划分好，下面定义更清晰</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">allStu</span>[2]= &#123;</span></span><br><span class="line">        &#123;<span class="number">1</span>,<span class="string">"lisi"</span>,<span class="string">"f"</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="string">"lily"</span>,<span class="string">"M"</span>&#125;</span><br><span class="line">    &#125;;<span class="comment">//这是结构体数组</span></span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"id=%d,stdInfo.name=%s,stdInfo.sex=%c"</span>,allStu[i].id,allStu[i].stdInfo.name,allStu[i].stdInfo.sex);<span class="comment">//在结构体套结构体时在读取要小心</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="结构体作为形参"><a href="#结构体作为形参" class="headerlink" title="结构体作为形参"></a>结构体作为形参</h2><h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(struct stu tmp)</span></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp.name,<span class="string">"lily"</span>);</span><br><span class="line">    tmp.age = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name=%s,age=%d"</span>,tmp.name,tmp.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">   setInof(s); <span class="comment">//按值传递</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"name=%s,age=%d"</span>,s.name,s.age); <span class="comment">//结果没有被改变</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="按引用传递"><a href="#按引用传递" class="headerlink" title="按引用传递"></a>按引用传递</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(struct stu * tmp)</span></span>&#123;</span><br><span class="line">   <span class="built_in">strcpy</span>(tmp-&gt;name,<span class="string">"lily"</span>);</span><br><span class="line">   tmp-&gt;age = <span class="number">18</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"name=%s,age=%d"</span>,tmp.name,tmp.age);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">  setInof(&amp;s); <span class="comment">//按值传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"name=%s,age=%d"</span>,s.name,s.age); <span class="comment">//结果被改变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="结构体数组为参数"><a href="#结构体数组为参数" class="headerlink" title="结构体数组为参数"></a>结构体数组为参数</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(struct stu * tmp,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp-&gt;name,<span class="string">"stuname%d"</span>,i);</span><br><span class="line">    tmp-&gt;age = <span class="number">80</span>+i;</span><br><span class="line">    tmp++; <span class="comment">//相当于移动一个结构中的一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[2] = &#123;</span><span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(s)/<span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(s[<span class="number">0</span>]));</span><br><span class="line">    setInfo(s,n);<span class="comment">//数组默认传是引用</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%s, %d\n"</span>, s[i].name, s[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="const修饰结构体形参"><a href="#const修饰结构体形参" class="headerlink" title="const修饰结构体形参"></a>const修饰结构体形参</h3><blockquote><p>const 关键字修饰起到防止对源数据的更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//结构体类型的定义</span></span><br><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//注意const所在的位置（更详细搜：const全局变量与const局部变量区别）</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(struct stu * <span class="keyword">const</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//p = NULL; //err</span></span><br><span class="line">p-&gt;age = <span class="number">10</span>; <span class="comment">//ok</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">  </span><br><span class="line">&gt;<span class="comment">//void fun2(struct stu const*  p)</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">const</span> struct stu *  p)</span></span>&#123;</span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="comment">//p-&gt;age = 10; //err</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">(<span class="keyword">const</span> struct stu * <span class="keyword">const</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//p = NULL; //err</span></span><br><span class="line"><span class="comment">//p-&gt;age = 10; //err</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;结构体的基本操作&quot;&gt;&lt;a href=&quot;#结构体的基本操作&quot; class=&quot;headerlink&quot; title=&quot;结构体的基本操作&quot;&gt;&lt;/a&gt;结构体的基本操作&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这个数据类型可以用来表复杂的数据类型，由于C语言中的数组只能存放相
      
    
    </summary>
    
    
      <category term="C" scheme="http://www.chenweiqin.com/categories/C/"/>
    
    
      <category term="C基础" scheme="http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>sizeof的用法及与strlen比较</title>
    <link href="http://www.chenweiqin.com/2019/12/12/sizeof%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E4%B8%8Estrlen%E6%AF%94%E8%BE%83/"/>
    <id>http://www.chenweiqin.com/2019/12/12/sizeof的用法及与strlen比较/</id>
    <published>2019-12-12T08:32:03.000Z</published>
    <updated>2019-12-12T09:03:50.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sizeof与strlen比较"><a href="#sizeof与strlen比较" class="headerlink" title="sizeof与strlen比较"></a>sizeof与strlen比较</h2><blockquote><ol><li><p>相同点：</p><p>返回值都以字节为单位,<span style="color:red">无符号整型值</span>,为什么要强调这一点，当无符号整型与有符号整型进行运行时，一般会返回无符号值，在下面会举例说明。</p></li><li><p>不同点：</p><p>sizeof是运算符，会计算出变量类型所占的大小或变量实际占用大小，而strlen是函数返回字符串有效的长度，而不会加上\0，即字符串结束符。</p></li></ol><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(str));<span class="comment">//6</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(str));<span class="comment">//5 因为不没有把\0计算进来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sizeof与strlen比较&quot;&gt;&lt;a href=&quot;#sizeof与strlen比较&quot; class=&quot;headerlink&quot; title=&quot;sizeof与strlen比较&quot;&gt;&lt;/a&gt;sizeof与strlen比较&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="C" scheme="http://www.chenweiqin.com/categories/C/"/>
    
    
      <category term="C基础" scheme="http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>typedef用法</title>
    <link href="http://www.chenweiqin.com/2019/12/11/typedef%E7%94%A8%E6%B3%95/"/>
    <id>http://www.chenweiqin.com/2019/12/11/typedef用法/</id>
    <published>2019-12-11T13:51:03.000Z</published>
    <updated>2019-12-12T06:32:51.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typedef与define的区别"><a href="#typedef与define的区别" class="headerlink" title="typedef与define的区别"></a>typedef与define的区别</h2><blockquote><ol><li><p>#define发生在预处理，typedef发生在编译阶段</p></li><li><p>与#define不同，typedef限于数据类型，而不是能表达式或具体的值</p><p>二、具体使用对比</p></li><li><p>宏替换，只能使用#define,如果#define PI 3.14</p></li><li><p>简单起别名　#define uint32 unsigned int或typedef unsigned int uint32;其实这两个是一样的。</p></li><li><p>＃define 只有前者生效　#define PCHAR char *; PCHAR p1,p2;只有p1被声明为指针，但如果换成typedef 效果就不一样了。typedef char  * PCHAR; PCHAR P1,P2; 此时p1,p2都被声明为指针</p></li><li><p>＃define 无法用于简化结构体的定义。#definde struct book{}; 编译是无法通过的</p></li></ol></blockquote><h2 id="typedef的用法"><a href="#typedef的用法" class="headerlink" title="typedef的用法"></a>typedef的用法</h2><h3 id="解决兼容不同平台引起的差异问题"><a href="#解决兼容不同平台引起的差异问题" class="headerlink" title="解决兼容不同平台引起的差异问题"></a>解决兼容不同平台引起的差异问题</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> REAL;<span class="comment">//但有些版本不支持long double 则可以改为</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> REAL;<span class="comment">//还不支持的话再改</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> REAL;</span><br><span class="line"><span class="comment">//这样</span></span><br><span class="line"><span class="comment">//在文件中定义变量时使用更为兼容的写法</span></span><br><span class="line">REAL a;<span class="comment">//等价于 float a; 起到等价写法</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="用于等价标记"><a href="#用于等价标记" class="headerlink" title="用于等价标记"></a>用于等价标记</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1,p2;<span class="comment">//前是为char *类型，后者为char</span></span><br><span class="line"><span class="comment">//如果想定义成两种都是char *类型，则必须要这样定义</span></span><br><span class="line"><span class="keyword">char</span> *p1,*p2;</span><br><span class="line"><span class="comment">//能否找到一种与上面等价的写法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * p_str;</span><br><span class="line">p_str p1,p2;<span class="comment">//与char *p1,*p2;定义的方式效果是一样的</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="用于结构体时简化了写法"><a href="#用于结构体时简化了写法" class="headerlink" title="用于结构体时简化了写法"></a>用于结构体时简化了写法</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平时在定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//接着使用结构体</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">lisi</span> = &#123;</span><span class="number">20</span>,<span class="string">"lisi"</span>&#125;; </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">zhangsan</span> = &#123;</span><span class="number">21</span>,<span class="string">"zhangsan"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当使用typedef后</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">&#125;TYPE_P;<span class="comment">//可以把上面的person也简写了</span></span><br><span class="line"><span class="comment">//使用结构体</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TYPE_P lisi=&#123;<span class="number">20</span>,<span class="string">"lisi"</span>&#125;;</span><br><span class="line">    TYPE_P zhangsan=&#123;<span class="number">20</span>,<span class="string">"zhangsan"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>小心在引用自身时会报错，因为typedef发生在编译阶段</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *pItem;</span><br><span class="line">    pNode pNext; <span class="comment">//因为它还没有存在PNode</span></span><br><span class="line">&#125; *pNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确使用方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *pItem; </span><br><span class="line">    pNode pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者以下这种方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *pItem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">pNode</span>;</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="同样可以简化指定及数组定义"><a href="#同样可以简化指定及数组定义" class="headerlink" title="同样可以简化指定及数组定义"></a>同样可以简化指定及数组定义</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT_ARR_10[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//上面定义后，就可以使用它</span></span><br><span class="line">INT_ARR_10 arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化指针的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * PCHAR;</span><br><span class="line">PCHAR name;<span class="comment">// 等价于char * name;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="更为高级用法简化函数的定义"><a href="#更为高级用法简化函数的定义" class="headerlink" title="更为高级用法简化函数的定义"></a>更为高级用法简化函数的定义</h3><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Function)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">//使用时</span></span><br><span class="line">Function　test;<span class="comment">//等价于 int test(const char *, const char *);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *(*a[<span class="number">5</span>])(<span class="keyword">int</span>,<span class="keyword">char</span>*);</span><br><span class="line"><span class="comment">// PFun是我们创建的一个类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *(*PFun)(<span class="keyword">int</span>,<span class="keyword">char</span>*);</span><br><span class="line"><span class="comment">// 使用定义的新类型来声明对象，等价于int*(*a[5])(int,char*);</span></span><br><span class="line">PFun a[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HANDLER)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">HANDLER <span class="title">Signal</span><span class="params">(<span class="keyword">int</span>,HANDLER)</span></span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">void</span> (*Signal(<span class="keyword">int</span>,<span class="keyword">void</span>(*)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="typedef注意事项"><a href="#typedef注意事项" class="headerlink" title="typedef注意事项"></a>typedef注意事项</h2><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* PCHAR;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrcmp</span><span class="params">(<span class="keyword">const</span> PCHAR,<span class="keyword">const</span> PCHAR)</span></span>;<span class="comment">//它是等价于</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrcmp</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span>,<span class="keyword">char</span>* <span class="keyword">const</span>)</span></span>;<span class="comment">//而非是等价于</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrcmp</span><span class="params">(<span class="keyword">const</span>　<span class="keyword">char</span>* ,<span class="keyword">const</span>　<span class="keyword">char</span>* )</span></span>;</span><br><span class="line"><span class="comment">//要想得到上面的效果则更改为</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">char</span> * PCHAR;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrcmp</span><span class="params">(PCHAR,PCHAR)</span></span>;</span><br></pre></td></tr></table></figure><p>还需要特别注意的是，虽然 typedef 并不真正影响对象的存储特性，但在语法上它还是一个存储类的关键字，就像 auto、extern、static 和 register 等关键字一样。因此，像下面这种声明方式是不可行的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">static</span> <span class="keyword">int</span> INT_STATIC;</span><br></pre></td></tr></table></figure><p>不可行的原因是不能声明多个存储类关键字，由于 typedef 已经占据了存储类关键字的位置，因此，在 typedef 声明中就不能够再使用 static 或任何其他存储类关键字了。当然，编译器也会报错，如在 VC++2010 中的报错信息为“无法指定多个存储类”。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;typedef与define的区别&quot;&gt;&lt;a href=&quot;#typedef与define的区别&quot; class=&quot;headerlink&quot; title=&quot;typedef与define的区别&quot;&gt;&lt;/a&gt;typedef与define的区别&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="C" scheme="http://www.chenweiqin.com/categories/C/"/>
    
    
      <category term="C基础" scheme="http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://www.chenweiqin.com/2019/12/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.chenweiqin.com/2019/12/03/内存管理/</id>
    <published>2019-12-03T02:57:19.000Z</published>
    <updated>2019-12-11T08:50:01.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><blockquote><p>一 、C语言的变量作用域分为：</p><ol><li>代码块作用域（代码块作用域就是在{}之间的代码）</li><li>函数作用域</li><li>文件作用域</li></ol><p>二、如果按作用范围分则分为：</p><ol><li><p>局部变量</p><blockquote><p>局部变量分划分为静态与非静态局部变量</p><p>1.1 非静态局部变量（也称之为auto自动变量，auto可以省略不写）</p><blockquote><ul><li>在函数内定义，只在函数范围内有效</li><li>在复合语句中定义，只在复合语句中有效（如:if(){//在这里定义了变量只在这里生效}）</li><li>随着函数调用的结束或复合语句的结束局部变量的生命周期也结束</li><li>如果没有赋初始值，则系统随机分配值（即垃圾值）</li></ul></blockquote><p>  1.2 静态局部变量（使用static进行修饰）</p><blockquote><ul><li><p>static 局部变量的作用域也是在所定义的函数内生效</p></li><li><p>static 局部变量的生命周期和程序运行周期一样</p></li><li><p>static 局部变量只能被初始化一次，但可以多次赋值</p></li><li><p>static 局部变量没有赋以初值时，系统则会对int型赋上0，字符型变量赋空字符串 </p></li></ul></blockquote></blockquote></li><li><p>全局变量</p><blockquote><p>全局变量同样可以划分为静态与非静态全局变量</p><p>2.1 非静态全局变量</p><blockquote><ul><li><p>在函数外定义，可被本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量，须用extern 声明</p></li><li><p>全局变量的生命周期和程序运行同期一样</p></li><li><p>不同文件的局部变量不同重名</p></li></ul></blockquote><p>2.2 静态全局变量</p><blockquote><ul><li>在函数外定义，作用范围被限制在所定义的文件中</li><li>不同的文件静态全局变量可以重名，便作用域不冲突</li><li>生命与程序运行周期一样，同时也只能被初始化一次</li></ul></blockquote></blockquote></li></ol></blockquote><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><blockquote><p>把C言语中函数可以划分为静态与非静态全局函数，因为在C语言中函数默认是全局的，使用了static修饰后称之为静态全局函数。</p><ol><li>静态全局函数</li></ol><blockquote><ul><li>此函数只能在当前文件中使用，不能别的文件中使用</li><li>不同的文件名中如果是静态函数文件名是可以相同的</li></ul></blockquote></blockquote><p>小结一下：</p><blockquote><ul><li>允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰。</li><li>同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。</li><li>所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。</li></ul></blockquote><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><h3 id="内存分区的意义"><a href="#内存分区的意义" class="headerlink" title="内存分区的意义"></a>内存分区的意义</h3><blockquote><p>将程序中不同的数据存放在不同的区域中（分区中），赋予它们不同的生命周期，给编程带来更大的灵活性。搞清楚每个区存放的数据时有什么特点，各种变量类型分别存放在那些分区中。不然在编写函数过程中往往接收不到函数的返回值，因为你接收的数据是存放在栈区，而函数调用结束后，由系统自动回收栈中的资源，有时在定义一个比较的数组时程序会报错，这是因为栈区的大小是固定的不能存比较大的数据。</p><p>阅读一个程序在内存中分区模型为会两种，一种是程序未执行时，另一种是当程序执行起来时，为什么可以这样划分？因为一个程序编译完成如果将这个程序运行起来在内存占的数据大小的是固定的（因为这些数据能预测出来），如（这个程序所有的指令长，静态数据/全局初始化数据/未初始数据），特点说明真正占用存内空间还是等到程序起来。还是数据只有程序真正运行起来才能知道占用内存的数据（如开辟了多个栈空间，申请了多少堆内存）</p><p><span style="color:red">程序未执行时</span>：一个c程序经过 预处理 编译 汇编 链接 4步后生成可执行文件。可能通过size 命令看到相关的信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="\img\c\size_file.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过上图得知，在没有运行程序前，也就是程序没有加载到内存前，可执行程序程序内部分好3区信息，分别为代码区（text）、初始化数据区（data）和未初始化数据区（bss）3个分区（有些人直接把data和bss合起来叫做静态区或全局区）</p><p><span style="color:red">程序加载到内存时</span>：代码区和全局区（data与bss）的大小就是固定不变的，当程序运行起来后，多了2个分区，分别是栈区与堆区</p></blockquote><h3 id="划分内存四区模型"><a href="#划分内存四区模型" class="headerlink" title="划分内存四区模型"></a>划分内存四区模型</h3><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="\img\c\mem_div.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在理解C/C++内在分区时，常会碰到如下术语：数据区，栈区，堆区，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等，把搞得云里雾里，在我眼里再把统一分类，<span style="color:red">程序是由数据与指令组成的则把它划分为2个区</span>：<span style="color:green">数据区与代码区</span></p><p>数据区：堆区，栈区，全局区/静态区</p><p>全局区/静态区：常量区，全局区/静态区[ =初始化数据区（data）和未初始化数据区（bss）]，以后别人说什么全局区/静态区就认为是：常量区+初始化数据区（data）+未初始化数据区（bss）</p><p>常量区：字符串常量区，const修饰全局变量</p><p> 代码区：存放程序编译后的二进制代码（也是机器指令）</p></blockquote><h3 id="各个分区特性"><a href="#各个分区特性" class="headerlink" title="各个分区特性"></a>各个分区特性</h3><blockquote><ol><li><p>代码区</p><blockquote><p>共享，只读不可修改。如运行了两个QQ.exe那么它的代码区是共享的，如果代码区中的内存不受保护那么程序就没有安全性可言了。</p></blockquote></li><li><p>全局区</p><blockquote><p>包括数据区 静态区 常量区。 生存周期为整个程序运行过程。</p><p>常量区的数据一量初始化，之后就是能修改了，只能读取。（如：”hello world” 符串常量，const修饰的全局变量 都是放在常量区的）</p></blockquote></li><li><p>栈区</p><blockquote><p>先进后出，由系统自动分配与释放。如函数的形参、返回值、局部变量，在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间即函数调用结束。栈区大小固定的，不能存放比较大的数据。</p></blockquote></li><li><p>堆区</p><blockquote><p>堆区是一个大容器，它的容量远远大于栈区，但没有栈那样先进后出的顺序。用于动态内存分配，堆区在内存中位于BSS区和栈区之间，一定要在程序手动申请手动释放，如果没有手动释放则会在程序结束时由操作系统回收，好是养成好的习惯用完了就把它释放掉</p></blockquote></li></ol></blockquote><h3 id="理解各个分区的案例"><a href="#理解各个分区的案例" class="headerlink" title="理解各个分区的案例"></a>理解各个分区的案例</h3><blockquote><ol><li><p>全局区</p><blockquote><p>１、把它们都定义在函数外面（即作用域全局有效）extern int flag=1 与 static int flag=1 有什么区别？</p><p>答：它们都是全局区，生存周期为程序运行结束，前者称之为外部链接符号，后者称之为内部链接号，说白了后者是在当前文件中全局有效，但不能跨文件使用它，前者无论是当前文件还是其它文件都可以使用它，使用时要加extern int flag , 告诉一下给编译器即可。</p><p>２、定义在函数外的static int a=1 与定义在函数内的static int a=1有什么区别？</p><p>答：相同点它们都是在静态区，生存周期为整个程序运行结束，不同点是前者的作用域为当前文件内全局有效，后者是局部变量，只能当前函数中使用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="\img\c\extern_static.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote></li><li><p>栈区</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">myFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不要返回局部变量的地址,因为它是栈区中的</span></span><br><span class="line">    <span class="keyword">int</span>　a =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *P = myFunc();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*p=%d"</span>,*p);<span class="comment">//得到的值是不确定的，可能是正确值，也有可以是垃圾值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="\img\c\stack1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>再看一下面的案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s =<span class="literal">NULL</span>;</span><br><span class="line">    s = getString();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s=%s\n"</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="\img\c\stack2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote></li><li><p>堆区</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getSpace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("%d\n",*&amp;p);</span></span><br><span class="line">   <span class="comment">//printf("%d\n",p);</span></span><br><span class="line">    <span class="keyword">int</span> j =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="number">100</span>+i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//返回p里面的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * ret = getSpace();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line">    ret = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//能正确输出结果</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="\img\c\head1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以上结果是正确输出hello world</p><p>那么如果正确输出正确有的结果，如下转化以下操作</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="\img\c\head2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></blockquote></li><li><p>常量区</p><blockquote><ol><li><p>const全局变量与const局部变量区别？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.const全局变量与const局部变量区别？除作用域不一样，它们所在内存中存放区也不一样（前都在数据区（也称之为全局区），后者是存放在栈区的）</span></span><br><span class="line"><span class="comment">//const全局变量在常量区，不能修改(直接或者间接都不能修改)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_c = <span class="number">100</span>;<span class="comment">//全局变量，存放在数据区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//直接修改不行</span></span><br><span class="line">    <span class="comment">//g_c=200 错误</span></span><br><span class="line">    <span class="comment">//间接修改也不行</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)&amp;g_c;<span class="comment">//&amp;g_c 是const int * 类型的，所有要强转换一下</span></span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//全局const放在常量区，一旦初始化，不能修改</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.const局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//栈上,它分配中在栈上，可以间接的修改它的值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">100</span>;<span class="comment">//局部　存放在栈区</span></span><br><span class="line">    <span class="comment">//a=200;不能够直接改变它的值</span></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>“hello world” 可以看成变量名;&amp;”hello world” 就可以打印出地址来 ,关于两个相同的字符串常量是否相同得出结论如下：</li></ol><p>tc2.0,同文件字符串常量地址不同。</p><p>vs2013,字符串常量地址同文件和不同文件都相同。</p><p>QT,同文件相同，不同文件不同。</p></blockquote></li></ol></blockquote><h2 id="动态操作内存"><a href="#动态操作内存" class="headerlink" title="动态操作内存"></a>动态操作内存</h2><h3 id="内存操作常见函数"><a href="#内存操作常见函数" class="headerlink" title="内存操作常见函数"></a>内存操作常见函数</h3><ol><li><p>malloc() </p><blockquote><p>vaoid *malloc(int size)</p><p>功能：在内存的动态存储区（堆区）中申请一块长度为size字节的连续区域</p><p>参数：size 需要申请内存大小(单位：字节)</p><p>返回值：注意如果当前内存不够的情况下有可能申请不成功，如果成功返回首地址（指针），失败返回NULL </p><p>注意事项：使用后必须进行内存回收，即malloc与free函数成对使用，对申请到内存空间进行及时释放，防止内存溢出 </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span> = (<span class="keyword">int</span> *) malloca(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);<span class="comment">//申请到一块连续内存大小为:4*10=40字节</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">NULL</span>)&#123; <span class="comment">//必须判断是否申请成功</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"申请空间失败\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对申请的内存空间进行初始化操作</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">array</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);<span class="comment">//把申请内存空间上的每个字节都重置为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对申请到空间进行赋值操作</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">array</span>[i] = i;<span class="comment">//在申请成功赋值给了int*类型指针，所有在这里可以用下标或者指针方式进行赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取结果</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用后记得释放,防止内存溢出</span></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>free()</p><blockquote><p>void free(void * p)</p><p>功能：释放p所指向的那一块内存空间，为释放区域的首地址，对同一个内存空间多次释放会报错</p><p>参数：p为释放空间的首地址</p><p>返回值：无</p></blockquote></li><li><p>memset()</p><blockquote><p>void *memset(void *s ,int value, int sizse)</p><p>功能：将以s为首地址重置为值为value,重置长度为size,特别说明size单位为字节</p><p>参数：</p><p>s : 操作的首地址</p><p>value: 把指定长度上的每个字节都重置为value，（一个字节占8位，所有value范围为0~255 　一般使用值0）</p><p>size:要重置的长度（字节数）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));<span class="comment">//把里面每个字节都重置为0</span></span><br><span class="line"><span class="keyword">char</span> * str = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10</span>);</span><br><span class="line"><span class="built_in">memset</span>(str,<span class="number">96</span>,<span class="number">10</span>);<span class="comment">//即重置为了"AAAAAAAAAA"</span></span><br><span class="line"><span class="built_in">free</span>(str);</span><br></pre></td></tr></table></figure></li><li><p>memcpy()</p><blockquote><p>void * memcpy(void * dest,const void * src, int size);</p><p>功能：拷贝src所指向内存内容前n个字节到dest所指的内存地址中</p><p>参数：</p><p>dest: 目的内存首地址</p><p>src: 源内存的首地址，注意:dest与src所指的内存空间不能重叠</p><p>size : 拷贝的字节数</p><p>返回值：dest 的首地址</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(b,a,<span class="keyword">sizeof</span>(a));<span class="comment">//把a数组中内容复制一份到b中</span></span><br></pre></td></tr></table></figure></li><li><p>memmove()</p><blockquote><p>功能与memcpy一样，区别于dest和src的所指向的内存空间出现重叠时，memmove仍然能执行，它执行效率比memcpy低</p></blockquote></li><li><p>memcmp()</p><blockquote><p>int memcmp(const void * s1,const void * s2, int size);</p><p>功能：比较s1和s2所指向内存区域的前size个字节</p><p>参数：</p><p>　s1:内存首地址１</p><p>　s2:内存首地址２</p><p>　size: 要比较的前多少个字节</p><p>返回值：</p><p>如果比较结果值相等:返回0, 大于:返回的值为&gt;0, 小于：返回的值为&lt;0</p></blockquote></li><li><p>calloc ()</p><blockquote><p>功能：分配空间并清空，等同于malloc + memset</p></blockquote></li><li><p>realloc()</p><blockquote><p>功能：重新分配内存空间，用于扩展和缩小空间</p><p>参数说明：</p><p>第一参数　　　　第二个参数　　　　　　行为</p><p>空　　　　　　　　无　　　　　　　　　同malloc</p><p>非空　　　　　　　０　　　　　　　　　原内存块被释放</p><p>非空　　　　　　　比原内存块小　　　　利用当前位置分配更小的内存块</p><p>非空　　　　　　　比原内存块大　　　　利用当前位置分配更大的内存块</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;h3 id=&quot;变量作用域&quot;&gt;&lt;a href=&quot;#变量作用域&quot; class=&quot;headerlink&quot; title=&quot;变量作用域&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="C" scheme="http://www.chenweiqin.com/categories/C/"/>
    
    
      <category term="C基础" scheme="http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>指针</title>
    <link href="http://www.chenweiqin.com/2019/11/28/%E6%8C%87%E9%92%88/"/>
    <id>http://www.chenweiqin.com/2019/11/28/指针/</id>
    <published>2019-11-27T22:34:21.000Z</published>
    <updated>2019-12-12T08:15:45.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h1><p>2018年10月25日 - 此系列文章我们开始聊一些软件开发人员如何开始动手写一些自己项目(<em>Side</em> <em>Project</em>)的思路与方法,以及过程中可能需要准备的知识,并分享一些相关的资源给..</p><h1 id="指针与数组关系"><a href="#指针与数组关系" class="headerlink" title="指针与数组关系"></a>指针与数组关系</h1><h2 id="通过指针写读取数组"><a href="#通过指针写读取数组" class="headerlink" title="通过指针写读取数组"></a>通过指针写读取数组</h2><p>2018年10月25日 - 此系列文章我们开始聊一些软件开发人员如何开始动手写一些自己项目(<em>Side</em> <em>Project</em>)的思路与方法,以及过程中可能需要准备的知识,并分享一些相关的资源给…</p><h2 id="通过指针操作二维数组"><a href="#通过指针操作二维数组" class="headerlink" title="通过指针操作二维数组"></a>通过指针操作二维数组</h2><p>2018年10月25日 - 此系列文章我们开始聊一些软件开发人员如何开始动手写一些自己项目(<em>Side</em> <em>Project</em>)的思路与方法,以及过程中可能需要准备的知识,并分享一些相关的资源给…</p><h1 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h1><h2 id="指针作为函数参数时"><a href="#指针作为函数参数时" class="headerlink" title="指针作为函数参数时"></a>指针作为函数参数时</h2><h2 id="指针作为函数返回值"><a href="#指针作为函数返回值" class="headerlink" title="指针作为函数返回值"></a>指针作为函数返回值</h2><h2 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h2><p><img src="%5Cimg%5Cc%5Css.jpg" alt=""></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="\img\c\tt.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是指针&quot;&gt;&lt;a href=&quot;#什么是指针&quot; class=&quot;headerlink&quot; title=&quot;什么是指针&quot;&gt;&lt;/a&gt;什么是指针&lt;/h1&gt;&lt;p&gt;2018年10月25日 - 此系列文章我们开始聊一些软件开发人员如何开始动手写一些自己项目(&lt;em&gt;Side&lt;/em
      
    
    </summary>
    
    
      <category term="C" scheme="http://www.chenweiqin.com/categories/C/"/>
    
    
      <category term="C基础" scheme="http://www.chenweiqin.com/tags/C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="指针" scheme="http://www.chenweiqin.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
